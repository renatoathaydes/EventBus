// script called by the GMaven plugin

import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream

def targetDir = new File( project.build.directory )
if ( !targetDir.exists() )
	fail 'Cannot proceed as the target directory does not exist'

// warn if any Jars are not actually OSGi bundles in the build directory
// collects the names of valid bundles
def bundleNames = [ ]
targetDir.eachFileMatch( ~/.*\.jar/ ) {
	if ( isValidBundle( it ) ) bundleNames << it.name
}

// create config.ini file for OSGI Eclipse Equinox
configDir = new File( targetDir, "configuration" )
configDir.mkdir()
def configFile = new File( configDir, "config.ini" )
if ( configFile.exists() ) configFile.delete()

exclude = [ 'osgi-' ]
doNotStart = [ 'test-osgi-app' ]
configFile.withWriter { writer ->
	writer.write '# Generated by Groovy Script during Maven build\n\n'
	writer.write 'osgi.bundles=\\\n'
	writer.write bundleEntries( bundleNames, exclude, doNotStart )
	writer.write '\neclipse.ignoreApp=true\n'
	writer.write 'org.ops4j.pax.logging.DefaultServiceLog.level=DEBUG'
}

/***** Helper Functions *****/

def isValidBundle( File jar ) {
	ZipInputStream zis = new ZipInputStream( new FileInputStream( jar ) )

	ZipEntry ze
	def hasManifest = false
	try {
		while ( ze = zis.nextEntry ) {
			if ( ze.name == 'META-INF/MANIFEST.MF' ) {
				hasManifest = true
				break;
			}
		}
		if ( !hasManifest ) log.info "No manifest found in ${jar.name}"
		if ( !hasManifest || !isBundle( zis ) ) {
			log.warn "${jar.name} does not seem to be a valid bundle!"
			return false
		} else
			return true
	} finally {
		if ( zis ) zis.close()
	}
}

def isBundle( inputStream ) {
	def countHeaders = 0
	inputStream.eachLine {
		if ( isMandatoryHeader( it ) ) countHeaders++
	}
	return countHeaders > 1
}

def isMandatoryHeader( line ) {
	line = line.trim().toLowerCase()
	return line.startsWith( 'bundle-symbolicname' ) ||
			line.startsWith( 'bundle-version' )
}

def bundleEntries( List<String> bundleNames, List<String> exclude, List<String> doNotStart ) {
	bundleNames.collect { bundleName ->
		exclude.find { bundleName.startsWith( it ) } ? '*' :
			bundleName + ( doNotStart.find { bundleName.startsWith( it ) } ? '@10' : '@start' )
	}.toString()[ 1..-2 ].replaceAll( /\, \*|\*\, /, '' ).replace( ', ', ',\\\n' )
}
